{"version":3,"sources":["../src/monitor.js"],"names":["Monitor","VERSION","Selectors","SCROLL_MONITOR","Data","MONITOR_TARGET","Events","SCROLL","DOM_CONTENT_LOADED","ValidTargetTypes","Window","Element","MonitorMap","Map","Resolvers","Set","target","window","_checkTarget","has","get","destroy","_target","_subscribers","_scrollMetric","_resolveMetric","_boundEventListener","_onTargetScroll","bind","addEventListener","set","subscriber","_checkSubscriber","add","delete","removeEventListener","event","lastMetric","resolver","resolvedEvent","resolve","Event","dispatchEvent","_checkResolver","forEach","monitor","clear","document","querySelectorAll","targetData","dataset","of","subscribe","metric","ScrollMetric","innerHeight","innerWidth","pageYOffset","pageXOffset","scrollHeight","scrollWidth","scrollTop","scrollLeft","Error","type","map","name","join","requiredFunctions","every","requiredFunc","Function","eventResolver","Resolver","height","width","top","left","_height","_width","_top","_left","_initByData"],"mappings":";;;;;;AAEA;;;;;;AAOA,IAAMA,UAAW,YAAM;AAErB,MAAMC,UAAU,OAAhB;AAEA,MAAMC,YAAY;AAChBC,oBAAgB;AADA,GAAlB;AAIA,MAAMC,OAAO;AACXC,oBAAgB;AADL,GAAb;AAIA,MAAMC,SAAS;AACbC,YAAQ,QADK;AAEbC,wBAAoB;AAFP,GAAf;AAKA,MAAMC,mBAAmB,CAACC,MAAD,EAASC,OAAT,CAAzB;AAEA,MAAMC,aAAa,IAAIC,GAAJ,EAAnB;AACA,MAAMC,YAAY,IAAIC,GAAJ,EAAlB;;AApBqB,MAsBff,OAtBe;AAAA;AAAA;AAuBnB;;;;;;;AAOA,qBAAYgB,MAAZ,EAAoB;AAAA;;AAClBA,eAASA,UAAUC,MAAnB;;AACAjB,cAAQkB,YAAR,CAAqBF,MAArB;;AAEA,UAAIJ,WAAWO,GAAX,CAAeH,MAAf,CAAJ,EAA4B;AAC1BJ,mBAAWQ,GAAX,CAAeJ,MAAf,EAAuBK,OAAvB;AACD;;AAED,WAAKC,OAAL,GAAeN,MAAf;AACA,WAAKO,YAAL,GAAoB,IAAIR,GAAJ,EAApB;AACA,WAAKS,aAAL,GAAqBxB,QAAQyB,cAAR,CAAuBT,MAAvB,CAArB;AACA,WAAKU,mBAAL,GAA2B,KAAKC,eAAL,CAAqBC,IAArB,CAA0B,IAA1B,CAA3B;;AAEA,WAAKN,OAAL,CAAaO,gBAAb,CAA8BvB,OAAOC,MAArC,EAA6C,KAAKmB,mBAAlD;;AACAd,iBAAWkB,GAAX,CAAed,MAAf,EAAuB,IAAvB;AACD,KA7CkB,CA+CnB;;;AA/CmB;AAAA;AAqKnB;;AAEA;;;;;AAvKmB,gCA4KTe,UA5KS,EA4KG;AACpB/B,gBAAQgC,gBAAR,CAAyBD,UAAzB;;AACA,aAAKR,YAAL,CAAkBU,GAAlB,CAAsBF,UAAtB;AACD;AAED;;;;;AAjLmB;AAAA;AAAA,kCAqLPA,UArLO,EAqLK;AACtB,aAAKR,YAAL,CAAkBW,MAAlB,CAAyBH,UAAzB;AACD;AAED;;;;;AAzLmB;AAAA;AAAA,gCA6LT;AACRnB,mBAAWsB,MAAX,CAAkB,KAAKZ,OAAvB;;AACA,aAAKA,OAAL,CAAaa,mBAAb,CAAiC7B,OAAOC,MAAxC,EAAgD,KAAKmB,mBAArD;;AAEA,aAAKJ,OAAL,GAAe,IAAf;AACA,aAAKC,YAAL,GAAoB,IAApB;AACA,aAAKC,aAAL,GAAqB,IAArB;AACA,aAAKE,mBAAL,GAA2B,IAA3B;AACD,OArMkB,CAuMnB;;AAvMmB;AAAA;AAAA,sCAyMHU,KAzMG,EAyMI;AACrB,YAAMC,aAAa,KAAKb,aAAxB;AACA,aAAKA,aAAL,GAAqBxB,QAAQyB,cAAR,CAAuB,KAAKH,OAA5B,CAArB;AAFqB;AAAA;AAAA;;AAAA;AAIrB,+BAAuBR,SAAvB,8HAAkC;AAAA,gBAAvBwB,QAAuB;AAChC,gBAAMC,gBAAgBD,SAASE,OAAT,CAAiBH,UAAjB,EAA6B,KAAKb,aAAlC,EAAiDY,KAAjD,CAAtB;;AACA,gBAAIG,iBAAiBA,yBAAyBE,KAA9C,EAAqD;AAAA;AAAA;AAAA;;AAAA;AACnD,sCAAyB,KAAKlB,YAA9B,mIAA4C;AAAA,sBAAjCQ,UAAiC;AAC1CA,6BAAWW,aAAX,CAAyBH,aAAzB;AACD;AAHkD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIpD;AACF;AAXoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYtB;AArNkB;AAAA;;AAqEnB;;;;;;;;AArEmB,yBA6ETvB,MA7ES,EA6ED;AAChBhB,gBAAQkB,YAAR,CAAqBF,MAArB;;AACA,YAAIJ,WAAWO,GAAX,CAAeH,MAAf,CAAJ,EAA4B;AAC1B,iBAAOJ,WAAWQ,GAAX,CAAeJ,MAAf,CAAP;AACD,SAFD,MAEO;AACL,iBAAO,IAAIhB,OAAJ,CAAYgB,MAAZ,CAAP;AACD;AACF;AAED;;;;;;AAtFmB;AAAA;AAAA,uCA2FKsB,QA3FL,EA2Fe;AAChC,aAAKK,cAAL,CAAoBL,QAApB;;AACAxB,kBAAUmB,GAAV,CAAcK,QAAd;AACD;AAED;;;;;AAhGmB;AAAA;AAAA,yCAoGOA,QApGP,EAoGiB;AAClCxB,kBAAUoB,MAAV,CAAiBI,QAAjB;AACD;AAED;;;;AAxGmB;AAAA;AAAA,8BA2GJ;AACb1B,mBAAWgC,OAAX,CAAmB;AAAA,iBAAWC,QAAQxB,OAAR,EAAX;AAAA,SAAnB;AACAP,kBAAUgC,KAAV;AACD;AAED;;;;;AAhHmB;AAAA;AAAA,oCAoHE;AAAA;AAAA;AAAA;;AAAA;AACnB,gCAAyBC,SAASC,gBAAT,CAA0B9C,UAAUC,cAApC,CAAzB,mIAA8E;AAAA,gBAAnE4B,UAAmE;AAC5E,gBAAMkB,aAAalB,WAAWmB,OAAX,CAAmB9C,KAAKC,cAAxB,CAAnB;;AACA,gBAAI4C,UAAJ,EAAgB;AAAA;AAAA;AAAA;;AAAA;AACd,sCAAqBF,SAASC,gBAAT,CAA0BC,UAA1B,CAArB,mIAA4D;AAAA,sBAAjDjC,MAAiD;AAC1DhB,0BAAQmD,EAAR,CAAWnC,MAAX,EAAmBoC,SAAnB,CAA6BrB,UAA7B;AACD;AAHa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIf,aAJD,MAIO;AACL/B,sBAAQmD,EAAR,CAAWlC,MAAX,EAAmBmC,SAAnB,CAA6BrB,UAA7B;AACD;AACF;AAVkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWpB;AA/HkB;AAAA;AAAA,qCAiIGf,MAjIH,EAiIW;AAC5B,YAAIqC,MAAJ;;AACA,YAAIrC,kBAAkBN,MAAtB,EAA8B;AAC5B2C,mBAAS,IAAIC,YAAJ,CAAiBtC,OAAOuC,WAAxB,EAAqCvC,OAAOwC,UAA5C,EACPxC,OAAOyC,WADA,EACazC,OAAO0C,WADpB,CAAT;AAED,SAHD,MAGO,IAAI1C,kBAAkBL,OAAtB,EAA+B;AACpC0C,mBAAS,IAAIC,YAAJ,CAAiBtC,OAAO2C,YAAxB,EAAsC3C,OAAO4C,WAA7C,EACP5C,OAAO6C,SADA,EACW7C,OAAO8C,UADlB,CAAT;AAED,SAHM,MAGA;AACL,gBAAM,IAAIC,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,eAAOV,MAAP;AACD;AA7IkB;AAAA;AAAA,mCA+ICrC,MA/ID,EA+IS;AAC1B,8BAAmBP,gBAAnB,eAAqC;AAAhC,cAAMuD,OAAQvD,gBAAR,IAAN;;AACH,cAAIO,kBAAkBgD,IAAtB,EAA4B;AAC1B;AACD;AACF;;AACD,cAAM,IAAID,KAAJ,oDAAsDtD,iBAAiBwD,GAAjB,CAAqB;AAAA,iBAAQD,KAAKE,IAAb;AAAA,SAArB,EAAwCC,IAAxC,CAA6C,IAA7C,CAAtD,OAAN;AACD;AAtJkB;AAAA;AAAA,uCAwJKpC,UAxJL,EAwJiB;AAClC,YAAMqC,oBAAoB,CAAC,kBAAD,EAAqB,qBAArB,EAA4C,eAA5C,CAA1B;;AACA,YAAI,CAAEA,kBAAkBC,KAAlB,CAAwB;AAAA,iBAAgBtC,WAAWuC,YAAX,aAAoCC,QAApD;AAAA,SAAxB,CAAN,EAA8F;AAC5F,gBAAM,IAAIR,KAAJ,8CAAgDK,iBAAhD,OAAN;AACD;AACF;AA7JkB;AAAA;AAAA,qCA+JGI,aA/JH,EA+JkB;AACnC,YAAI,EAAEA,yBAAyBC,QAA3B,CAAJ,EAA0C;AACxC,gBAAM,IAAIV,KAAJ,CAAU,+CAAV,CAAN;AACD;AACF;AAnKkB;AAAA;AAAA,0BAiDE;AACnB,eAAO9D,OAAP;AACD;AAED;;;;;AArDmB;AAAA;AAAA,0BAyDK;AACtB,eAAO,IAAIY,GAAJ,CAAQD,UAAR,CAAP;AACD;AAED;;;;;AA7DmB;AAAA;AAAA,0BAiEI;AACrB,eAAO,IAAIG,GAAJ,CAAQD,SAAR,CAAP;AACD;AAnEkB;;AAAA;AAAA;;AAAA,MAyNfwC,YAzNe;AAAA;AAAA;AA0NnB,0BAAYoB,MAAZ,EAAoBC,KAApB,EAA2BC,GAA3B,EAAgCC,IAAhC,EAAsC;AAAA;;AACpC,WAAKC,OAAL,GAAeJ,MAAf;AACA,WAAKK,MAAL,GAAcJ,KAAd;AACA,WAAKK,IAAL,GAAYJ,GAAZ;AACA,WAAKK,KAAL,GAAaJ,IAAb;AACD,KA/NkB,CAiOnB;;;AAjOmB;AAAA;AAAA,0BAmON;AACX,eAAO,KAAKC,OAAZ;AACD;AArOkB;AAAA;AAAA,0BAuOP;AACV,eAAO,KAAKC,MAAZ;AACD;AAzOkB;AAAA;AAAA,0BA2OT;AACR,eAAO,KAAKC,IAAZ;AACD;AA7OkB;AAAA;AAAA,0BA+OR;AACT,eAAO,KAAKC,KAAZ;AACD;AAjPkB;;AAAA;AAAA;;AAoPrBhE,SAAOY,gBAAP,CAAwBvB,OAAOE,kBAA/B,EAAmD,YAAM;AACvDR,YAAQkF,WAAR;AACD,GAFD;AAIA,SAAOlF,OAAP;AACD,CAzPe,EAAhB","sourcesContent":["import Resolver from './resolver'\n\n/**\n * ----------------------------------------------------------------------------------\n * ScrollMonitor (v0.1.0): monitor.js\n * Licensed under MIT (https://github.com/swgrhck/scroll-monitor/blob/master/LICENSE)\n * ----------------------------------------------------------------------------------\n */\n\nconst Monitor = (() => {\n\n  const VERSION = '0.1.0'\n\n  const Selectors = {\n    SCROLL_MONITOR: '[data-monitor~=\"scroll\"]'\n  }\n\n  const Data = {\n    MONITOR_TARGET: 'monitorTarget'\n  }\n\n  const Events = {\n    SCROLL: 'scroll',\n    DOM_CONTENT_LOADED: 'DOMContentLoaded'\n  }\n\n  const ValidTargetTypes = [Window, Element]\n\n  const MonitorMap = new Map()\n  const Resolvers = new Set()\n\n  class Monitor {\n    /**\n     * This method will destroy the Monitor of the target if exists, then return a new one.\n     * Consider use {@link Monitor.of} instead.\n     * @param target the target of the monitor\n     * @throws when target is invalid\n     * @see Monitor.of\n     */\n    constructor(target) {\n      target = target || window\n      Monitor._checkTarget(target)\n\n      if (MonitorMap.has(target)) {\n        MonitorMap.get(target).destroy()\n      }\n\n      this._target = target\n      this._subscribers = new Set()\n      this._scrollMetric = Monitor._resolveMetric(target)\n      this._boundEventListener = this._onTargetScroll.bind(this)\n\n      this._target.addEventListener(Events.SCROLL, this._boundEventListener)\n      MonitorMap.set(target, this)\n    }\n\n    // Static\n\n    static get VERSION() {\n      return VERSION\n    }\n\n    /**\n     * Return the copy of the monitor map whose keys are targets and values are monitors\n     * @return {Map<Window | Element, Monitor>}\n     */\n    static get monitorMap() {\n      return new Map(MonitorMap)\n    }\n\n    /**\n     * Return the copy of a Set contains all registered resolvers\n     * @return {Set<Resolver>}\n     */\n    static get resolvers() {\n      return new Set(Resolvers)\n    }\n\n    /**\n     * Get the Monitor of the target.\n     * If the Monitor of the target exists, then return it.\n     * Otherwise, create a new Monitor for the target and return.\n     * @param target target of the monitor\n     * @throws when target is not valid\n     * @return {Monitor}\n     */\n    static of(target) {\n      Monitor._checkTarget(target)\n      if (MonitorMap.has(target)) {\n        return MonitorMap.get(target)\n      } else {\n        return new Monitor(target)\n      }\n    }\n\n    /**\n     * Register a new Resolver\n     * @param resolver should be an instance of {@link Resolver}\n     * @throws when resolver is not valid\n     */\n    static registerResolver(resolver) {\n      this._checkResolver(resolver)\n      Resolvers.add(resolver)\n    }\n\n    /**\n     * Unregister a resolver\n     * @param resolver the resolver should be unregistered\n     */\n    static unregisterResolver(resolver) {\n      Resolvers.delete(resolver)\n    }\n\n    /**\n     * Destroy all managed Monitors and unregister all Resolvers\n     */\n    static reset() {\n      MonitorMap.forEach(monitor => monitor.destroy())\n      Resolvers.clear()\n    }\n\n    /**\n     * Create monitors and add subscribers to monitors by data attributes.\n     * This function can be invoked repeatedly safely, subscribers will not be registered repeatedly.\n     */\n    static _initByData() {\n      for (const subscriber of document.querySelectorAll(Selectors.SCROLL_MONITOR)) {\n        const targetData = subscriber.dataset[Data.MONITOR_TARGET]\n        if (targetData) {\n          for (const target of document.querySelectorAll(targetData)) {\n            Monitor.of(target).subscribe(subscriber)\n          }\n        } else {\n          Monitor.of(window).subscribe(subscriber)\n        }\n      }\n    }\n\n    static _resolveMetric(target) {\n      let metric\n      if (target instanceof Window) {\n        metric = new ScrollMetric(target.innerHeight, target.innerWidth,\n          target.pageYOffset, target.pageXOffset)\n      } else if (target instanceof Element) {\n        metric = new ScrollMetric(target.scrollHeight, target.scrollWidth,\n          target.scrollTop, target.scrollLeft)\n      } else {\n        throw new Error('Can not resolve ScrollMetric')\n      }\n      return metric\n    }\n\n    static _checkTarget(target) {\n      for (const type of ValidTargetTypes) {\n        if (target instanceof type) {\n          return\n        }\n      }\n      throw new Error(`The target must be an instance of one in ${ValidTargetTypes.map(type => type.name).join(', ')}!`)\n    }\n\n    static _checkSubscriber(subscriber) {\n      const requiredFunctions = ['addEventListener', 'removeEventListener', 'dispatchEvent']\n      if (!(requiredFunctions.every(requiredFunc => subscriber[requiredFunc] instanceof Function))) {\n        throw new Error(`The subscriber must have functions ${requiredFunctions}!`)\n      }\n    }\n\n    static _checkResolver(eventResolver) {\n      if (!(eventResolver instanceof Resolver)) {\n        throw new Error('The resolver must be an instance of Resolver!')\n      }\n    }\n\n    // Public\n\n    /**\n     * Add a new subscriber to the Monitor.\n     * @param subscriber should be an instance of {@link EventTarget}\n     * @throws when subscriber is not valid\n     */\n    subscribe(subscriber) {\n      Monitor._checkSubscriber(subscriber)\n      this._subscribers.add(subscriber)\n    }\n\n    /**\n     * Remove a subscriber from the Monitor.\n     * @param subscriber the subscriber should be removed from the monitor\n     */\n    unsubscribe(subscriber) {\n      this._subscribers.delete(subscriber)\n    }\n\n    /**\n     * Destroy the Monitor.\n     * Once this method invoked, this Monitor would not be available anymore.\n     */\n    destroy() {\n      MonitorMap.delete(this._target)\n      this._target.removeEventListener(Events.SCROLL, this._boundEventListener)\n\n      this._target = null\n      this._subscribers = null\n      this._scrollMetric = null\n      this._boundEventListener = null\n    }\n\n    // Private\n\n    _onTargetScroll(event) {\n      const lastMetric = this._scrollMetric\n      this._scrollMetric = Monitor._resolveMetric(this._target)\n\n      for (const resolver of Resolvers) {\n        const resolvedEvent = resolver.resolve(lastMetric, this._scrollMetric, event)\n        if (resolvedEvent && resolvedEvent instanceof Event) {\n          for (const subscriber of this._subscribers) {\n            subscriber.dispatchEvent(resolvedEvent)\n          }\n        }\n      }\n    }\n\n  }\n\n  class ScrollMetric {\n    constructor(height, width, top, left) {\n      this._height = height\n      this._width = width\n      this._top = top\n      this._left = left\n    }\n\n    // Getter\n\n    get height() {\n      return this._height\n    }\n\n    get width() {\n      return this._width\n    }\n\n    get top() {\n      return this._top\n    }\n\n    get left() {\n      return this._left\n    }\n  }\n\n  window.addEventListener(Events.DOM_CONTENT_LOADED, () => {\n    Monitor._initByData()\n  })\n\n  return Monitor\n})()\n\nexport default Monitor\n"],"file":"monitor.js"}