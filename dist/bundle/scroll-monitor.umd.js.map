{"version":3,"file":"scroll-monitor.umd.js","sources":["../../src/util.js","../../src/resolver.js","../../src/monitor.js","../../src/scroll-up.js"],"sourcesContent":["const Util = (() => {\n  const Util = {\n    createEvent(type, options) {\n      const defaultOptions = {bubbles: false, cancelable: false, composed: false}\n      options = Object.assign(defaultOptions, options)\n      if (document.documentMode) { // if IE\n        const event = document.createEvent('Event')\n        event.initEvent(type, options.bubbles, options.cancelable)\n        return event\n      } else {\n        return new Event(type, options)\n      }\n    }\n  }\n\n  return Util\n})()\n\nexport default Util\n","/**\n * ----------------------------------------------------------------------------------\n * ScrollMonitor (v0.1.0): resolver.js\n * Licensed under MIT (https://github.com/swgrhck/scroll-monitor/blob/master/LICENSE)\n * ----------------------------------------------------------------------------------\n */\n\nconst Resolver = (() => {\n\n  const VERSION = '0.1.0'\n  const EVENT_NAMESPACE = 'scroll-monitor'\n\n  class Resolver {\n    // Getter\n\n    static get VERSION() {\n      return VERSION\n    }\n\n    static get NAMESPACE() {\n      return EVENT_NAMESPACE\n    }\n\n    /**\n     * Return an array of event types this revolver will generate\n     */\n    get eventTypes() {\n    }\n\n    // Public\n\n    /**\n     * Resolve metrics and event received from Monitor and\n     * return a new resolved Event which should be dispatched to subscribers of Monitor\n     * @param lastMetric last scroll metric\n     * @param crtMetric current scroll metric\n     * @param event the scroll event that monitor received\n     * @return {Event}\n     */\n    resolve(lastMetric, crtMetric, event) { // eslint-disable-line no-unused-vars\n      throw new Error('Method is not implemented. Instance must override this method to resolve scroll event!')\n    }\n  }\n\n  return Resolver\n})()\n\nexport default Resolver\n","import Resolver from './resolver'\n\n/**\n * ----------------------------------------------------------------------------------\n * ScrollMonitor (v0.1.0): monitor.js\n * Licensed under MIT (https://github.com/swgrhck/scroll-monitor/blob/master/LICENSE)\n * ----------------------------------------------------------------------------------\n */\n\nconst Monitor = (() => {\n\n  const VERSION = '0.1.0'\n\n  const Selectors = {\n    SCROLL_MONITOR: '[data-monitor~=\"scroll\"]'\n  }\n\n  const Data = {\n    MONITOR_TARGET: 'monitorTarget'\n  }\n\n  const Events = {\n    SCROLL: 'scroll',\n    DOM_CONTENT_LOADED: 'DOMContentLoaded'\n  }\n\n  const ValidTargetTypes = [Window, Element]\n\n  const MonitorMap = new Map()\n  const Resolvers = new Set()\n\n  class Monitor {\n    /**\n     * This method will destroy the Monitor of the target if exists, then return a new one.\n     * Consider use {@link Monitor.of} instead.\n     * @param target the target of the monitor\n     * @throws when target is invalid\n     * @see Monitor.of\n     */\n    constructor(target) {\n      target = target || window\n      Monitor._checkTarget(target)\n\n      if (MonitorMap.has(target)) {\n        MonitorMap.get(target).destroy()\n      }\n\n      this._target = target\n      this._subscribers = new Set()\n      this._scrollMetric = Monitor._resolveMetric(target)\n      this._boundEventListener = this._onTargetScroll.bind(this)\n\n      this._target.addEventListener(Events.SCROLL, this._boundEventListener)\n      MonitorMap.set(target, this)\n    }\n\n    // Static\n\n    static get VERSION() {\n      return VERSION\n    }\n\n    /**\n     * Return the copy of the monitor map whose keys are targets and values are monitors\n     * @return {Map<Window | Element, Monitor>}\n     */\n    static get monitorMap() {\n      return new Map(MonitorMap)\n    }\n\n    /**\n     * Return the copy of a Set contains all registered resolvers\n     * @return {Set<Resolver>}\n     */\n    static get resolvers() {\n      return new Set(Resolvers)\n    }\n\n    /**\n     * Get the Monitor of the target.\n     * If the Monitor of the target exists, then return it.\n     * Otherwise, create a new Monitor for the target and return.\n     * @param target target of the monitor\n     * @throws when target is not valid\n     * @return {Monitor}\n     */\n    static of(target) {\n      Monitor._checkTarget(target)\n      if (MonitorMap.has(target)) {\n        return MonitorMap.get(target)\n      } else {\n        return new Monitor(target)\n      }\n    }\n\n    /**\n     * Register a new Resolver\n     * @param resolver should be an instance of {@link Resolver}\n     * @throws when resolver is not valid\n     */\n    static registerResolver(resolver) {\n      this._checkResolver(resolver)\n      Resolvers.add(resolver)\n    }\n\n    /**\n     * Unregister a resolver\n     * @param resolver the resolver should be unregistered\n     */\n    static unregisterResolver(resolver) {\n      Resolvers.delete(resolver)\n    }\n\n    /**\n     * Destroy all managed Monitors and unregister all Resolvers\n     */\n    static reset() {\n      MonitorMap.forEach(monitor => monitor.destroy())\n      Resolvers.clear()\n    }\n\n    /**\n     * Create monitors and add subscribers to monitors by data attributes.\n     * This function can be invoked repeatedly safely, subscribers will not be registered repeatedly.\n     */\n    static _initByData() {\n      for (const subscriber of document.querySelectorAll(Selectors.SCROLL_MONITOR)) {\n        const targetData = subscriber.dataset[Data.MONITOR_TARGET]\n        if (targetData) {\n          for (const target of document.querySelectorAll(targetData)) {\n            Monitor.of(target).subscribe(subscriber)\n          }\n        } else {\n          Monitor.of(window).subscribe(subscriber)\n        }\n      }\n    }\n\n    static _resolveMetric(target) {\n      let metric\n      if (target instanceof Window) {\n        metric = new ScrollMetric(target.innerHeight, target.innerWidth,\n          target.pageYOffset, target.pageXOffset)\n      } else if (target instanceof Element) {\n        metric = new ScrollMetric(target.scrollHeight, target.scrollWidth,\n          target.scrollTop, target.scrollLeft)\n      } else {\n        throw new Error('Can not resolve ScrollMetric')\n      }\n      return metric\n    }\n\n    static _checkTarget(target) {\n      for (const type of ValidTargetTypes) {\n        if (target instanceof type) {\n          return\n        }\n      }\n      throw new Error(`The target must be an instance of one in ${ValidTargetTypes.map(type => type.name).join(', ')}!`)\n    }\n\n    static _checkSubscriber(subscriber) {\n      const requiredFunctions = ['addEventListener', 'removeEventListener', 'dispatchEvent']\n      if (!(requiredFunctions.every(requiredFunc => subscriber[requiredFunc] instanceof Function))) {\n        throw new Error(`The subscriber must have functions ${requiredFunctions}!`)\n      }\n    }\n\n    static _checkResolver(eventResolver) {\n      if (!(eventResolver instanceof Resolver)) {\n        throw new Error('The resolver must be an instance of Resolver!')\n      }\n    }\n\n    // Public\n\n    /**\n     * Add a new subscriber to the Monitor.\n     * @param subscriber should be an instance of {@link EventTarget}\n     * @throws when subscriber is not valid\n     */\n    subscribe(subscriber) {\n      Monitor._checkSubscriber(subscriber)\n      this._subscribers.add(subscriber)\n    }\n\n    /**\n     * Remove a subscriber from the Monitor.\n     * @param subscriber the subscriber should be removed from the monitor\n     */\n    unsubscribe(subscriber) {\n      this._subscribers.delete(subscriber)\n    }\n\n    /**\n     * Destroy the Monitor.\n     * Once this method invoked, this Monitor would not be available anymore.\n     */\n    destroy() {\n      MonitorMap.delete(this._target)\n      this._target.removeEventListener(Events.SCROLL, this._boundEventListener)\n\n      this._target = null\n      this._subscribers = null\n      this._scrollMetric = null\n      this._boundEventListener = null\n    }\n\n    // Private\n\n    _onTargetScroll(event) {\n      const lastMetric = this._scrollMetric\n      this._scrollMetric = Monitor._resolveMetric(this._target)\n\n      for (const resolver of Resolvers) {\n        const resolvedEvent = resolver.resolve(lastMetric, this._scrollMetric, event)\n        if (resolvedEvent && resolvedEvent instanceof Event) {\n          for (const subscriber of this._subscribers) {\n            subscriber.dispatchEvent(resolvedEvent)\n          }\n        }\n      }\n    }\n\n  }\n\n  class ScrollMetric {\n    constructor(height, width, top, left) {\n      this._height = height\n      this._width = width\n      this._top = top\n      this._left = left\n    }\n\n    // Getter\n\n    get height() {\n      return this._height\n    }\n\n    get width() {\n      return this._width\n    }\n\n    get top() {\n      return this._top\n    }\n\n    get left() {\n      return this._left\n    }\n  }\n\n  window.addEventListener(Events.DOM_CONTENT_LOADED, () => {\n    Monitor._initByData()\n  })\n\n  return Monitor\n})()\n\nexport default Monitor\n","import Util from './util'\nimport Resolver from './resolver'\nimport Monitor from './monitor'\n\n/**\n * ----------------------------------------------------------------------------------\n * ScrollMonitor (v0.1.0): scroll-up.js\n * Licensed under MIT (https://github.com/swgrhck/scroll-monitor/blob/master/LICENSE)\n * ----------------------------------------------------------------------------------\n */\n\nconst ScrollUpResolver = (() => {\n\n  const VERSION = '0.1.0'\n\n  const Selectors = {\n    SCROLL_UP_MONITOR: '[data-monitor~=\"scroll-up\"]'\n  }\n\n  const Data = {\n    TOGGLE_CLASS: 'scrollUpClass'\n  }\n\n  const DataDefault = {\n    TOGGLE_CLASS: 'scroll-up'\n  }\n\n  const Events = {\n    SCROLL_UP: `scroll.up.${Resolver.NAMESPACE}`,\n    SCROLL_UP_OFF: `scroll.up.off.${Resolver.NAMESPACE}`,\n    DOM_CONTENT_LOADED: 'DOMContentLoaded'\n  }\n\n  class ScrollUpResolver extends Resolver {\n\n    static get VERSION() {\n      return VERSION\n    }\n\n    get eventTypes() {\n      return [Events.SCROLL_UP, Events.SCROLL_UP_OFF]\n    }\n\n    /**\n     * Add class toggle event listeners those respond to events of {@link ScrollUpResolver} to subscribers by data attributes.\n     * This function can NOT be invoked repeatedly safely, event listeners will be registered repeatedly.\n     */\n    static _initByData() {\n      for (const subscriber of document.querySelectorAll(Selectors.SCROLL_UP_MONITOR)) {\n        const toggleClass = subscriber.dataset[Data.TOGGLE_CLASS] || DataDefault.TOGGLE_CLASS\n        subscriber.addEventListener(Events.SCROLL_UP, () => {\n          subscriber.classList.add(toggleClass)\n        })\n        subscriber.addEventListener(Events.SCROLL_UP_OFF, () => {\n          subscriber.classList.remove(toggleClass)\n        })\n      }\n    }\n\n    resolve(lastMetric, crtMetric) {\n      let lastTop = lastMetric.top\n      let crtTop = crtMetric.top\n      if (crtTop < lastTop) {\n        return Util.createEvent(Events.SCROLL_UP)\n      } else {\n        return Util.createEvent(Events.SCROLL_UP_OFF)\n      }\n    }\n  }\n\n  window.addEventListener(Events.DOM_CONTENT_LOADED, () => {\n    Monitor.registerResolver(new ScrollUpResolver())\n    ScrollUpResolver._initByData()\n  })\n\n  return ScrollUpResolver\n})()\n\nexport default ScrollUpResolver\n"],"names":["Util","createEvent","type","options","defaultOptions","bubbles","cancelable","composed","Object","assign","document","documentMode","event","initEvent","Event","Resolver","VERSION","EVENT_NAMESPACE","lastMetric","crtMetric","Error","Monitor","Selectors","SCROLL_MONITOR","Data","MONITOR_TARGET","Events","SCROLL","DOM_CONTENT_LOADED","ValidTargetTypes","Window","Element","MonitorMap","Map","Resolvers","Set","target","window","_checkTarget","has","get","destroy","_target","_subscribers","_scrollMetric","_resolveMetric","_boundEventListener","_onTargetScroll","bind","addEventListener","set","subscriber","_checkSubscriber","add","delete","removeEventListener","resolver","resolvedEvent","resolve","dispatchEvent","_checkResolver","forEach","monitor","clear","querySelectorAll","targetData","dataset","of","subscribe","metric","ScrollMetric","innerHeight","innerWidth","pageYOffset","pageXOffset","scrollHeight","scrollWidth","scrollTop","scrollLeft","map","name","join","requiredFunctions","every","requiredFunc","Function","eventResolver","height","width","top","left","_height","_width","_top","_left","_initByData","ScrollUpResolver","SCROLL_UP_MONITOR","TOGGLE_CLASS","DataDefault","SCROLL_UP","NAMESPACE","SCROLL_UP_OFF","lastTop","crtTop","toggleClass","classList","remove","registerResolver"],"mappings":"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"}