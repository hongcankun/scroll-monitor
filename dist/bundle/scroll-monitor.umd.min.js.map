{
  "version": 3, "sources": ["../../src/resolver.js", "../../src/monitor.js", "../../src/scroll-up.js"], "names": [
  "Selectors", "Data", "Events", "ValidTargetTypes", "MonitorMap", "Resolvers", "Monitor", "ScrollMetric",
  "DataDefault", "ScrollUpResolver", "Resolver", "_classCallCheck", "this", "_createClass", "key", "value",
  "lastMetric", "crtMetric", "event", "Error", "get", "Window", "Element", "Map", "Set", "target", "window",
  "_checkTarget", "has", "destroy", "_target", "_subscribers", "_scrollMetric", "_resolveMetric", "_boundEventListener",
  "_onTargetScroll", "bind", "addEventListener", "set", "subscriber", "_checkSubscriber", "add", "delete",
  "removeEventListener", "_iteratorNormalCompletion", "_didIteratorError", "_iteratorError", "undefined", "_step",
  "_iterator", "Symbol", "iterator", "next", "done", "resolvedEvent", "resolve", "Event", "_iteratorNormalCompletion2",
  "_didIteratorError2", "_iteratorError2", "_step2", "_iterator2", "dispatchEvent", "err", "return", "resolver",
  "_checkResolver", "forEach", "monitor", "clear", "_iteratorNormalCompletion3", "_didIteratorError3",
  "_iteratorError3", "_step3", "_iterator3", "document", "querySelectorAll", "targetData", "dataset",
  "_iteratorNormalCompletion4", "_didIteratorError4", "_iteratorError4", "_step4", "_iterator4", "of", "subscribe",
  "metric", "innerHeight", "innerWidth", "pageYOffset", "pageXOffset", "scrollHeight", "scrollWidth", "scrollTop",
  "scrollLeft", "_i", "length", "concat", "map", "type", "name", "join", "EventTarget", "eventResolver", "height",
  "width", "top", "left", "_height", "_width", "_top", "_left", "_initByData", "SCROLL_UP", "NAMESPACE",
  "SCROLL_UP_OFF", "DOM_CONTENT_LOADED", "_Resolver", "_possibleConstructorReturn", "_getPrototypeOf", "apply",
  "arguments", "lastTop", "_loop", "toggleClass", "classList", "remove", "_inherits", "registerResolver"
],
  "mappings": "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",
  "file": "scroll-monitor.umd.min.js", "sourcesContent": [
  "/**\n * ----------------------------------------------------------------------------------\n * ScrollMonitor (v0.1.0): resolver.js\n * Licensed under MIT (https://github.com/swgrhck/scroll-monitor/blob/master/LICENSE)\n * ----------------------------------------------------------------------------------\n */\n\nconst Resolver = (() => {\n\n  const VERSION = '0.1.0'\n  const EVENT_NAMESPACE = 'scroll-monitor'\n\n  class Resolver {\n    // Getter\n\n    static get VERSION() {\n      return VERSION\n    }\n\n    static get NAMESPACE() {\n      return EVENT_NAMESPACE\n    }\n\n    /**\n     * Return an array of event types this revolver will generate\n     */\n    get eventTypes() {\n    }\n\n    // Public\n\n    /**\n     * Resolve metrics and event received from Monitor and\n     * return a new resolved Event which should be dispatched to subscribers of Monitor\n     * @param lastMetric last scroll metric\n     * @param crtMetric current scroll metric\n     * @param event the scroll event that monitor received\n     * @return {Event}\n     */\n    resolve(lastMetric, crtMetric, event) { // eslint-disable-line no-unused-vars\n      throw new Error('Method is not implemented. Instance must override this method to resolve scroll event!')\n    }\n  }\n\n  return Resolver\n})()\n\nexport default Resolver\n",
  "import Resolver from './resolver'\n\n/**\n * ----------------------------------------------------------------------------------\n * ScrollMonitor (v0.1.0): monitor.js\n * Licensed under MIT (https://github.com/swgrhck/scroll-monitor/blob/master/LICENSE)\n * ----------------------------------------------------------------------------------\n */\n\nconst Monitor = (() => {\n\n  const VERSION = '0.1.0'\n\n  const Selectors = {\n    SCROLL_MONITOR: '[data-monitor~=\"scroll\"]'\n  }\n\n  const Data = {\n    MONITOR_TARGET: 'monitorTarget'\n  }\n\n  const Events = {\n    SCROLL: 'scroll',\n    DOM_CONTENT_LOADED: 'DOMContentLoaded'\n  }\n\n  const ValidTargetTypes = [Window, Element]\n\n  const MonitorMap = new Map()\n  const Resolvers = new Set()\n\n  class Monitor {\n    /**\n     * This method will destroy the Monitor of the target if exists, then return a new one.\n     * Consider use {@link Monitor.of} instead.\n     * @param target the target of the monitor\n     * @throws when target is invalid\n     * @see Monitor.of\n     */\n    constructor(target) {\n      target = target || window\n      Monitor._checkTarget(target)\n\n      if (MonitorMap.has(target)) {\n        MonitorMap.get(target).destroy()\n      }\n\n      this._target = target\n      this._subscribers = new Set()\n      this._scrollMetric = Monitor._resolveMetric(target)\n      this._boundEventListener = this._onTargetScroll.bind(this)\n\n      this._target.addEventListener(Events.SCROLL, this._boundEventListener)\n      MonitorMap.set(target, this)\n    }\n\n    // Static\n\n    static get VERSION() {\n      return VERSION\n    }\n\n    /**\n     * Return the copy of the monitor map whose keys are targets and values are monitors\n     * @return {Map<Window | Element, Monitor>}\n     */\n    static get monitorMap() {\n      return new Map(MonitorMap)\n    }\n\n    /**\n     * Return the copy of a Set contains all registered resolvers\n     * @return {Set<Resolver>}\n     */\n    static get resolvers() {\n      return new Set(Resolvers)\n    }\n\n    /**\n     * Get the Monitor of the target.\n     * If the Monitor of the target exists, then return it.\n     * Otherwise, create a new Monitor for the target and return.\n     * @param target target of the monitor\n     * @throws when target is not valid\n     * @return {Monitor}\n     */\n    static of(target) {\n      Monitor._checkTarget(target)\n      if (MonitorMap.has(target)) {\n        return MonitorMap.get(target)\n      } else {\n        return new Monitor(target)\n      }\n    }\n\n    /**\n     * Register a new Resolver\n     * @param resolver should be an instance of {@link Resolver}\n     * @throws when resolver is not valid\n     */\n    static registerResolver(resolver) {\n      this._checkResolver(resolver)\n      Resolvers.add(resolver)\n    }\n\n    /**\n     * Unregister a resolver\n     * @param resolver the resolver should be unregistered\n     */\n    static unregisterResolver(resolver) {\n      Resolvers.delete(resolver)\n    }\n\n    /**\n     * Destroy all managed Monitors and unregister all Resolvers\n     */\n    static reset() {\n      MonitorMap.forEach(monitor => monitor.destroy())\n      Resolvers.clear()\n    }\n\n    /**\n     * Create monitors and add subscribers to monitors by data attributes.\n     * This function can be invoked repeatedly safely, subscribers will not be registered repeatedly.\n     */\n    static _initByData() {\n      for (const subscriber of document.querySelectorAll(Selectors.SCROLL_MONITOR)) {\n        const targetData = subscriber.dataset[Data.MONITOR_TARGET]\n        if (targetData) {\n          for (const target of document.querySelectorAll(targetData)) {\n            Monitor.of(target).subscribe(subscriber)\n          }\n        } else {\n          Monitor.of(window).subscribe(subscriber)\n        }\n      }\n    }\n\n    static _resolveMetric(target) {\n      let metric\n      if (target instanceof Window) {\n        metric = new ScrollMetric(target.innerHeight, target.innerWidth,\n          target.pageYOffset, target.pageXOffset)\n      } else if (target instanceof Element) {\n        metric = new ScrollMetric(target.scrollHeight, target.scrollWidth,\n          target.scrollTop, target.scrollLeft)\n      } else {\n        throw new Error('Can not resolve ScrollMetric')\n      }\n      return metric\n    }\n\n    static _checkTarget(target) {\n      for (const type of ValidTargetTypes) {\n        if (target instanceof type) {\n          return\n        }\n      }\n      throw new Error(`The target must be an instance of one in ${ValidTargetTypes.map(type => type.name).join(', ')}!`)\n    }\n\n    static _checkSubscriber(subscriber) {\n      if (!(subscriber instanceof EventTarget)) {\n        throw new Error('The subscriber must be an instance of EventTarget!')\n      }\n    }\n\n    static _checkResolver(eventResolver) {\n      if (!(eventResolver instanceof Resolver)) {\n        throw new Error('The resolver must be an instance of Resolver!')\n      }\n    }\n\n    // Public\n\n    /**\n     * Add a new subscriber to the Monitor.\n     * @param subscriber should be an instance of {@link EventTarget}\n     * @throws when subscriber is not valid\n     */\n    subscribe(subscriber) {\n      Monitor._checkSubscriber(subscriber)\n      this._subscribers.add(subscriber)\n    }\n\n    /**\n     * Remove a subscriber from the Monitor.\n     * @param subscriber the subscriber should be removed from the monitor\n     */\n    unsubscribe(subscriber) {\n      this._subscribers.delete(subscriber)\n    }\n\n    /**\n     * Destroy the Monitor.\n     * Once this method invoked, this Monitor would not be available anymore.\n     */\n    destroy() {\n      MonitorMap.delete(this._target)\n      this._target.removeEventListener(Events.SCROLL, this._boundEventListener)\n\n      this._target = null\n      this._subscribers = null\n      this._scrollMetric = null\n      this._boundEventListener = null\n    }\n\n    // Private\n\n    _onTargetScroll(event) {\n      const lastMetric = this._scrollMetric\n      this._scrollMetric = Monitor._resolveMetric(this._target)\n\n      for (const resolver of Resolvers) {\n        const resolvedEvent = resolver.resolve(lastMetric, this._scrollMetric, event)\n        if (resolvedEvent && resolvedEvent instanceof Event) {\n          for (const subscriber of this._subscribers) {\n            subscriber.dispatchEvent(resolvedEvent)\n          }\n        }\n      }\n    }\n\n  }\n\n  class ScrollMetric {\n    constructor(height, width, top, left) {\n      this._height = height\n      this._width = width\n      this._top = top\n      this._left = left\n    }\n\n    // Getter\n\n    get height() {\n      return this._height\n    }\n\n    get width() {\n      return this._width\n    }\n\n    get top() {\n      return this._top\n    }\n\n    get left() {\n      return this._left\n    }\n  }\n\n  window.addEventListener(Events.DOM_CONTENT_LOADED, () => {\n    Monitor._initByData()\n  })\n\n  return Monitor\n})()\n\nexport default Monitor\n",
  "import Resolver from './resolver'\nimport Monitor from './monitor'\n\n/**\n * ----------------------------------------------------------------------------------\n * ScrollMonitor (v0.1.0): scroll-up.js\n * Licensed under MIT (https://github.com/swgrhck/scroll-monitor/blob/master/LICENSE)\n * ----------------------------------------------------------------------------------\n */\n\nconst ScrollUpResolver = (() => {\n\n  const VERSION = '0.1.0'\n\n  const Selectors = {\n    SCROLL_UP_MONITOR: '[data-monitor~=\"scroll-up\"]'\n  }\n\n  const Data = {\n    TOGGLE_CLASS: 'scrollUpClass'\n  }\n\n  const DataDefault = {\n    TOGGLE_CLASS: 'scroll-up'\n  }\n\n  const Events = {\n    SCROLL_UP: `scroll.up.${Resolver.NAMESPACE}`,\n    SCROLL_UP_OFF: `scroll.up.off.${Resolver.NAMESPACE}`,\n    DOM_CONTENT_LOADED: 'DOMContentLoaded'\n  }\n\n  class ScrollUpResolver extends Resolver {\n\n    static get VERSION() {\n      return VERSION\n    }\n\n    get eventTypes() {\n      return [Events.SCROLL_UP, Events.SCROLL_UP_OFF]\n    }\n\n    /**\n     * Add class toggle event listeners those respond to events of {@link ScrollUpResolver} to subscribers by data attributes.\n     * This function can NOT be invoked repeatedly safely, event listeners will be registered repeatedly.\n     */\n    static _initByData() {\n      for (const subscriber of document.querySelectorAll(Selectors.SCROLL_UP_MONITOR)) {\n        const toggleClass = subscriber.dataset[Data.TOGGLE_CLASS] || DataDefault.TOGGLE_CLASS\n        subscriber.addEventListener(Events.SCROLL_UP, () => {\n          subscriber.classList.add(toggleClass)\n        })\n        subscriber.addEventListener(Events.SCROLL_UP_OFF, () => {\n          subscriber.classList.remove(toggleClass)\n        })\n      }\n    }\n\n    resolve(lastMetric, crtMetric) {\n      let lastTop = lastMetric.top\n      let crtTop = crtMetric.top\n      if (crtTop < lastTop) {\n        return new Event(Events.SCROLL_UP)\n      } else {\n        return new Event(Events.SCROLL_UP_OFF)\n      }\n    }\n  }\n\n  window.addEventListener(Events.DOM_CONTENT_LOADED, () => {\n    Monitor.registerResolver(new ScrollUpResolver())\n    ScrollUpResolver._initByData()\n  })\n\n  return ScrollUpResolver\n})()\n\nexport default ScrollUpResolver\n"
]
}
