{"version":3,"sources":["../../src/util.js","../../src/resolver.js","../../src/monitor.js","../../src/scroll-up.js"],"names":["Util","createEvent","type","options","Object","assign","bubbles","cancelable","composed","document","documentMode","event","initEvent","Event","Selectors","Data","Events","ValidTargetTypes","MonitorMap","Resolvers","Monitor","ScrollMetric","DataDefault","ScrollUpResolver","Resolver","_classCallCheck","this","_createClass","key","value","lastMetric","crtMetric","Error","get","Window","Element","Map","Set","target","window","_checkTarget","has","destroy","_target","_subscribers","_scrollMetric","_resolveMetric","_boundEventListener","_onTargetScroll","bind","addEventListener","set","subscriber","_checkSubscriber","add","delete","removeEventListener","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","resolvedEvent","resolve","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","dispatchEvent","err","return","resolver","_checkResolver","forEach","monitor","clear","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","querySelectorAll","targetData","dataset","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","of","subscribe","metric","innerHeight","innerWidth","pageYOffset","pageXOffset","scrollHeight","scrollWidth","scrollTop","scrollLeft","_i","length","concat","map","name","join","requiredFunctions","every","requiredFunc","Function","eventResolver","height","width","top","left","_height","_width","_top","_left","_initByData","SCROLL_UP","NAMESPACE","SCROLL_UP_OFF","DOM_CONTENT_LOADED","_Resolver","_possibleConstructorReturn","_getPrototypeOf","apply","arguments","lastTop","_loop","toggleClass","classList","remove","_inherits","registerResolver"],"mappings":"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","file":"scroll-monitor.umd.min.js","sourcesContent":["const Util = (() => {\n  const Util = {\n    createEvent(type, options) {\n      const defaultOptions = {bubbles: false, cancelable: false, composed: false}\n      options = Object.assign(defaultOptions, options)\n      if (document.documentMode) { // if IE\n        const event = document.createEvent('Event')\n        event.initEvent(type, options.bubbles, options.cancelable)\n        return event\n      } else {\n        return new Event(type, options)\n      }\n    }\n  }\n\n  return Util\n})()\n\nexport default Util\n","/**\n * ----------------------------------------------------------------------------------\n * ScrollMonitor (v0.1.0): resolver.js\n * Licensed under MIT (https://github.com/swgrhck/scroll-monitor/blob/master/LICENSE)\n * ----------------------------------------------------------------------------------\n */\n\nconst Resolver = (() => {\n\n  const VERSION = '0.1.0'\n  const EVENT_NAMESPACE = 'scroll-monitor'\n\n  class Resolver {\n    // Getter\n\n    static get VERSION() {\n      return VERSION\n    }\n\n    static get NAMESPACE() {\n      return EVENT_NAMESPACE\n    }\n\n    /**\n     * Return an array of event types this revolver will generate\n     */\n    get eventTypes() {\n    }\n\n    // Public\n\n    /**\n     * Resolve metrics and event received from Monitor and\n     * return a new resolved Event which should be dispatched to subscribers of Monitor\n     * @param lastMetric last scroll metric\n     * @param crtMetric current scroll metric\n     * @param event the scroll event that monitor received\n     * @return {Event}\n     */\n    resolve(lastMetric, crtMetric, event) { // eslint-disable-line no-unused-vars\n      throw new Error('Method is not implemented. Instance must override this method to resolve scroll event!')\n    }\n  }\n\n  return Resolver\n})()\n\nexport default Resolver\n","import Resolver from './resolver'\n\n/**\n * ----------------------------------------------------------------------------------\n * ScrollMonitor (v0.1.0): monitor.js\n * Licensed under MIT (https://github.com/swgrhck/scroll-monitor/blob/master/LICENSE)\n * ----------------------------------------------------------------------------------\n */\n\nconst Monitor = (() => {\n\n  const VERSION = '0.1.0'\n\n  const Selectors = {\n    SCROLL_MONITOR: '[data-monitor~=\"scroll\"]'\n  }\n\n  const Data = {\n    MONITOR_TARGET: 'monitorTarget'\n  }\n\n  const Events = {\n    SCROLL: 'scroll',\n    DOM_CONTENT_LOADED: 'DOMContentLoaded'\n  }\n\n  const ValidTargetTypes = [Window, Element]\n\n  const MonitorMap = new Map()\n  const Resolvers = new Set()\n\n  class Monitor {\n    /**\n     * This method will destroy the Monitor of the target if exists, then return a new one.\n     * Consider use {@link Monitor.of} instead.\n     * @param target the target of the monitor\n     * @throws when target is invalid\n     * @see Monitor.of\n     */\n    constructor(target) {\n      target = target || window\n      Monitor._checkTarget(target)\n\n      if (MonitorMap.has(target)) {\n        MonitorMap.get(target).destroy()\n      }\n\n      this._target = target\n      this._subscribers = new Set()\n      this._scrollMetric = Monitor._resolveMetric(target)\n      this._boundEventListener = this._onTargetScroll.bind(this)\n\n      this._target.addEventListener(Events.SCROLL, this._boundEventListener)\n      MonitorMap.set(target, this)\n    }\n\n    // Static\n\n    static get VERSION() {\n      return VERSION\n    }\n\n    /**\n     * Return the copy of the monitor map whose keys are targets and values are monitors\n     * @return {Map<Window | Element, Monitor>}\n     */\n    static get monitorMap() {\n      return new Map(MonitorMap)\n    }\n\n    /**\n     * Return the copy of a Set contains all registered resolvers\n     * @return {Set<Resolver>}\n     */\n    static get resolvers() {\n      return new Set(Resolvers)\n    }\n\n    /**\n     * Get the Monitor of the target.\n     * If the Monitor of the target exists, then return it.\n     * Otherwise, create a new Monitor for the target and return.\n     * @param target target of the monitor\n     * @throws when target is not valid\n     * @return {Monitor}\n     */\n    static of(target) {\n      Monitor._checkTarget(target)\n      if (MonitorMap.has(target)) {\n        return MonitorMap.get(target)\n      } else {\n        return new Monitor(target)\n      }\n    }\n\n    /**\n     * Register a new Resolver\n     * @param resolver should be an instance of {@link Resolver}\n     * @throws when resolver is not valid\n     */\n    static registerResolver(resolver) {\n      this._checkResolver(resolver)\n      Resolvers.add(resolver)\n    }\n\n    /**\n     * Unregister a resolver\n     * @param resolver the resolver should be unregistered\n     */\n    static unregisterResolver(resolver) {\n      Resolvers.delete(resolver)\n    }\n\n    /**\n     * Destroy all managed Monitors and unregister all Resolvers\n     */\n    static reset() {\n      MonitorMap.forEach(monitor => monitor.destroy())\n      Resolvers.clear()\n    }\n\n    /**\n     * Create monitors and add subscribers to monitors by data attributes.\n     * This function can be invoked repeatedly safely, subscribers will not be registered repeatedly.\n     */\n    static _initByData() {\n      for (const subscriber of document.querySelectorAll(Selectors.SCROLL_MONITOR)) {\n        const targetData = subscriber.dataset[Data.MONITOR_TARGET]\n        if (targetData) {\n          for (const target of document.querySelectorAll(targetData)) {\n            Monitor.of(target).subscribe(subscriber)\n          }\n        } else {\n          Monitor.of(window).subscribe(subscriber)\n        }\n      }\n    }\n\n    static _resolveMetric(target) {\n      let metric\n      if (target instanceof Window) {\n        metric = new ScrollMetric(target.innerHeight, target.innerWidth,\n          target.pageYOffset, target.pageXOffset)\n      } else if (target instanceof Element) {\n        metric = new ScrollMetric(target.scrollHeight, target.scrollWidth,\n          target.scrollTop, target.scrollLeft)\n      } else {\n        throw new Error('Can not resolve ScrollMetric')\n      }\n      return metric\n    }\n\n    static _checkTarget(target) {\n      for (const type of ValidTargetTypes) {\n        if (target instanceof type) {\n          return\n        }\n      }\n      throw new Error(`The target must be an instance of one in ${ValidTargetTypes.map(type => type.name).join(', ')}!`)\n    }\n\n    static _checkSubscriber(subscriber) {\n      const requiredFunctions = ['addEventListener', 'removeEventListener', 'dispatchEvent']\n      if (!(requiredFunctions.every(requiredFunc => subscriber[requiredFunc] instanceof Function))) {\n        throw new Error(`The subscriber must have functions ${requiredFunctions}!`)\n      }\n    }\n\n    static _checkResolver(eventResolver) {\n      if (!(eventResolver instanceof Resolver)) {\n        throw new Error('The resolver must be an instance of Resolver!')\n      }\n    }\n\n    // Public\n\n    /**\n     * Add a new subscriber to the Monitor.\n     * @param subscriber should be an instance of {@link EventTarget}\n     * @throws when subscriber is not valid\n     */\n    subscribe(subscriber) {\n      Monitor._checkSubscriber(subscriber)\n      this._subscribers.add(subscriber)\n    }\n\n    /**\n     * Remove a subscriber from the Monitor.\n     * @param subscriber the subscriber should be removed from the monitor\n     */\n    unsubscribe(subscriber) {\n      this._subscribers.delete(subscriber)\n    }\n\n    /**\n     * Destroy the Monitor.\n     * Once this method invoked, this Monitor would not be available anymore.\n     */\n    destroy() {\n      MonitorMap.delete(this._target)\n      this._target.removeEventListener(Events.SCROLL, this._boundEventListener)\n\n      this._target = null\n      this._subscribers = null\n      this._scrollMetric = null\n      this._boundEventListener = null\n    }\n\n    // Private\n\n    _onTargetScroll(event) {\n      const lastMetric = this._scrollMetric\n      this._scrollMetric = Monitor._resolveMetric(this._target)\n\n      for (const resolver of Resolvers) {\n        const resolvedEvent = resolver.resolve(lastMetric, this._scrollMetric, event)\n        if (resolvedEvent && resolvedEvent instanceof Event) {\n          for (const subscriber of this._subscribers) {\n            subscriber.dispatchEvent(resolvedEvent)\n          }\n        }\n      }\n    }\n\n  }\n\n  class ScrollMetric {\n    constructor(height, width, top, left) {\n      this._height = height\n      this._width = width\n      this._top = top\n      this._left = left\n    }\n\n    // Getter\n\n    get height() {\n      return this._height\n    }\n\n    get width() {\n      return this._width\n    }\n\n    get top() {\n      return this._top\n    }\n\n    get left() {\n      return this._left\n    }\n  }\n\n  window.addEventListener(Events.DOM_CONTENT_LOADED, () => {\n    Monitor._initByData()\n  })\n\n  return Monitor\n})()\n\nexport default Monitor\n","import Util from './util'\nimport Resolver from './resolver'\nimport Monitor from './monitor'\n\n/**\n * ----------------------------------------------------------------------------------\n * ScrollMonitor (v0.1.0): scroll-up.js\n * Licensed under MIT (https://github.com/swgrhck/scroll-monitor/blob/master/LICENSE)\n * ----------------------------------------------------------------------------------\n */\n\nconst ScrollUpResolver = (() => {\n\n  const VERSION = '0.1.0'\n\n  const Selectors = {\n    SCROLL_UP_MONITOR: '[data-monitor~=\"scroll-up\"]'\n  }\n\n  const Data = {\n    TOGGLE_CLASS: 'scrollUpClass'\n  }\n\n  const DataDefault = {\n    TOGGLE_CLASS: 'scroll-up'\n  }\n\n  const Events = {\n    SCROLL_UP: `scroll.up.${Resolver.NAMESPACE}`,\n    SCROLL_UP_OFF: `scroll.up.off.${Resolver.NAMESPACE}`,\n    DOM_CONTENT_LOADED: 'DOMContentLoaded'\n  }\n\n  class ScrollUpResolver extends Resolver {\n\n    static get VERSION() {\n      return VERSION\n    }\n\n    get eventTypes() {\n      return [Events.SCROLL_UP, Events.SCROLL_UP_OFF]\n    }\n\n    /**\n     * Add class toggle event listeners those respond to events of {@link ScrollUpResolver} to subscribers by data attributes.\n     * This function can NOT be invoked repeatedly safely, event listeners will be registered repeatedly.\n     */\n    static _initByData() {\n      for (const subscriber of document.querySelectorAll(Selectors.SCROLL_UP_MONITOR)) {\n        const toggleClass = subscriber.dataset[Data.TOGGLE_CLASS] || DataDefault.TOGGLE_CLASS\n        subscriber.addEventListener(Events.SCROLL_UP, () => {\n          subscriber.classList.add(toggleClass)\n        })\n        subscriber.addEventListener(Events.SCROLL_UP_OFF, () => {\n          subscriber.classList.remove(toggleClass)\n        })\n      }\n    }\n\n    resolve(lastMetric, crtMetric) {\n      let lastTop = lastMetric.top\n      let crtTop = crtMetric.top\n      if (crtTop < lastTop) {\n        return Util.createEvent(Events.SCROLL_UP)\n      } else {\n        return Util.createEvent(Events.SCROLL_UP_OFF)\n      }\n    }\n  }\n\n  window.addEventListener(Events.DOM_CONTENT_LOADED, () => {\n    Monitor.registerResolver(new ScrollUpResolver())\n    ScrollUpResolver._initByData()\n  })\n\n  return ScrollUpResolver\n})()\n\nexport default ScrollUpResolver\n"]}